name: CD

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  quality-gate:
    name: Quality Gate (tests)
    runs-on: ubuntu-latest
    permissions:
      contents: read
    env:
      DATABASE_URL: "sqlite:///:memory:"
      SQLALCHEMY_DATABASE_URL: "sqlite:///:memory:"
      AWS_REGION: us-east-1
      AWS_ACCESS_KEY_ID: test
      AWS_SECRET_ACCESS_KEY: test
      SQS_VIDEO_PROCESSING_QUEUE: http://localhost:4566/000000000000/video-processing-queue
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: pip

      - name: Instalar dependências
        run: |
          python -m pip install --upgrade pip
          pip install -r .docker/bin/config/requirements.txt

      - name: Testes unitários
        env:
          PYTHONPATH: ${{ github.workspace }}
        run: |
          pytest -q tests/unit --cov=app --cov-report=term-missing

      - name: Smoke worker
        run: |
          bash tests/smoke/smoke-worker.sh

  sonar_main:
    name: SonarCloud (main)
    runs-on: ubuntu-latest
    permissions:
      contents: read
    env:
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      DATABASE_URL: "sqlite:///:memory:"
      SQLALCHEMY_DATABASE_URL: "sqlite:///:memory:"
      AWS_REGION: us-east-1
      AWS_ACCESS_KEY_ID: test
      AWS_SECRET_ACCESS_KEY: test
      SQS_VIDEO_PROCESSING_QUEUE: http://localhost:4566/000000000000/video-processing-queue
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: pip

      - name: Instalar dependências
        run: |
          python -m pip install --upgrade pip
          pip install -r .docker/bin/config/requirements.txt

      - name: Rodar testes unitários (com cobertura)
        env:
          PYTHONPATH: ${{ github.workspace }}
        run: |
          pytest -q tests/unit --cov=app --cov-report=xml:coverage.xml

      - name: Validar configuração do SonarCloud
        if: ${{ env.SONAR_TOKEN != '' }}
        env:
          SONAR_TOKEN: ${{ env.SONAR_TOKEN }}
        run: |
          if [ -z "${SONAR_TOKEN}" ]; then
            echo "::error::Secret SONAR_TOKEN não definido (Settings → Secrets and variables → Actions → Secrets)."
            exit 1
          fi

      - name: SonarCloud Scan
        if: ${{ env.SONAR_TOKEN != '' }}
        uses: SonarSource/sonarcloud-github-action@v2
        with:
          args: >
            -Dsonar.python.coverage.reportPaths=coverage.xml
            -Dsonar.sources=app
            -Dsonar.tests=tests
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ env.SONAR_TOKEN }}

  deploy:
    name: Deploy (ECR + ECS)
    runs-on: ubuntu-latest
    needs:
      - quality-gate
      - sonar_main
    timeout-minutes: 15
    permissions:
      id-token: write
      contents: read
    env:
      AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
      AWS_IAM_ROLE_ARN: ${{ vars.AWS_IAM_ROLE_ARN }}
      ECS_CLUSTER_NAME: ${{ vars.ECS_CLUSTER_NAME || 'hackathon-cluster' }}
      ECS_TASK_FAMILY: ${{ vars.ECS_TASK_FAMILY || 'hackathon-processor' }}
      ECS_SERVICE_NAME: ${{ vars.ECS_SERVICE_NAME || 'hackathon-processor' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validar variáveis obrigatórias
        run: |
          if [ -z "${AWS_IAM_ROLE_ARN}" ]; then
            echo "::error::Variable AWS_IAM_ROLE_ARN não definida (Settings → Actions → Variables)."
            exit 1
          fi

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_IAM_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login no Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build e push da imagem
        id: image
        env:
          REPO_NAME: ${{ github.event.repository.name }}
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          REGISTRY="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          IMAGE_URI="${REGISTRY}/${REPO_NAME}:${GITHUB_SHA}"

          echo "IMAGE_URI=${IMAGE_URI}" >> "$GITHUB_OUTPUT"

          docker build -t "$IMAGE_URI" .
          docker push "$IMAGE_URI"

      - name: Deploy no ECS (processor)
        env:
          IMAGE_URI: ${{ steps.image.outputs.IMAGE_URI }}
        run: |
          set -euo pipefail

          SERVICE_STATUS=$(aws ecs describe-services \
            --cluster "$ECS_CLUSTER_NAME" \
            --services "$ECS_SERVICE_NAME" \
            --query 'services[0].status' \
            --output text 2>/dev/null || true)

          if [ "$SERVICE_STATUS" != "ACTIVE" ]; then
            echo "Serviço ECS '$ECS_SERVICE_NAME' não está ACTIVE (status: $SERVICE_STATUS). Pulando deploy ECS."
            exit 0
          fi

          aws ecs describe-task-definition --task-definition "$ECS_TASK_FAMILY" --query taskDefinition > taskdef.json

          jq --arg IMAGE "$IMAGE_URI" '
            .containerDefinitions |= (
              map(
                .image = $IMAGE
                | del(.command)
                | .environment = ((.environment // [])
                    | map(select(.name != "APP_ENV" and .name != "AWS_S3_BUCKET"))
                    + [{"name":"APP_ENV","value":"production"}]
                    + (if any(.[]; .name == "S3_BUCKET")
                        then [{"name":"AWS_S3_BUCKET","value":((map(select(.name == "S3_BUCKET"))[0].value) // "")}]
                        else []
                      end)
                  )
              )
            )
            | del(
                .taskDefinitionArn,
                .revision,
                .status,
                .requiresAttributes,
                .compatibilities,
                .registeredAt,
                .registeredBy
              )
          ' taskdef.json > taskdef.rendered.json

          NEW_TASKDEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://taskdef.rendered.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          aws ecs update-service \
            --cluster "$ECS_CLUSTER_NAME" \
            --service "$ECS_SERVICE_NAME" \
            --task-definition "$NEW_TASKDEF_ARN" \
            --force-new-deployment

          aws ecs wait services-stable \
            --cluster "$ECS_CLUSTER_NAME" \
            --services "$ECS_SERVICE_NAME"
